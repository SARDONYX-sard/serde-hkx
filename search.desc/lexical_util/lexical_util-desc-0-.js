searchState.loadedDescShard("lexical_util", 0, "Shared utilities for lexical conversion routines.\nMaximum number of bytes required to serialize any number …\nEmpty byte array found.\nEmpty exponent found.\nEmpty fraction found.\nEmpty integer found.\nEmpty mantissa found.\nError code during parsing, indicating failure type.\nExponent was present without fraction component.\nMaximum number of bytes required to serialize a number to …\nMaximum number of bytes required to serialize a number to …\nThe size, in bytes, of formatted values.\nShort infinity string is too long.\nLong infinity string is too long.\nLong infinity string is too short: it must be as long as …\nInvalid character for a base prefix.\nInvalid character for a base suffix.\nInvalid consecutive exponent digit separator.\nInvalid consecutive fraction digit separator.\nInvalid consecutive integer digit separator.\nInvalid decimal point character.\nInvalid digit found before string termination.\nInvalid digit separator character.\nExponent was present but not allowed.\nInvalid base for the exponent.\nOptional exponent flags were set while disabling exponent …\nInvalid radix for the exponent digits.\nSet no positive exponent sign while requiring exponent …\nInvalid symbol to represent exponent notation.\nInvalid flags were set without the format feature.\nInvalid float parsing algorithm.\nInvalid precision flags for writing floats.\nInvalid short infinity string: must start with an <code>i</code> …\nInvalid long infinity string: must start with an <code>i</code> …\nInteger or integer component of float had invalid leading …\nInvalid radix for the mantissa (significant) digits.\nSet no positive mantissa sign while requiring mantissa …\nInvalid NaN string: must start with an <code>n</code> character.\nInvalid negative exponent break: break is above 0.\nInvalid negative sign for an unsigned type was found.\nInvalid positive exponent break: break is below 0.\nInvalid positive exponent sign was found.\nInvalid positive mantissa sign was found.\nInvalid positive sign for an integer was found.\nInvalid punctuation characters: multiple symbols overlap.\nInvalid radix for the significant digits.\nSet optional special float flags while disable special …\nNo exponent with required exponent notation.\nExponent sign was required(usize), but not found.\nMantissa sign was required(usize), but not found.\nIntegral sign was required(usize), but not found.\nNaN string is too long.\nIntegral overflow occurred during numeric parsing.\nAn error did not actually occur, and the result was …\nIntegral underflow occurred during numeric parsing.\nSimple, shared algorithms for slices and iterators.\nUtilities for working with ASCII characters.\nGet a description of the error in a const, panic friendly …\nUtilities to process digits.\nOptimized division algorithms for u128.\nExtended precision floating-point type.\nThe creation and processing of number format packed …\nReturns the argument unchanged.\nDefine the <code>FromLexical</code> trait.\nDefine the <code>FromLexicalWithOptions</code> trait.\nGet the index for the parsing error.\nCalls <code>U::from(self)</code>.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nSpecialized iterator traits.\nFast multiplication routines.\nUtilities for Rust numbers.\nShared traits for the options API.\nResult type for numeric parsing functions.\nThe maximum digits that can be held in a u64 for a given …\nDefine the <code>ToLexical</code> trait.\nDefine the <code>ToLexicalWithOptions</code> trait.\nCheck to see if parsing the float cannot possible overflow.\nCopy bytes from source to destination.\nCount the number of leading characters equal to a given …\nCount the number of trailing characters equal to a given …\nDetermine if a character is a valid ASCII character for …\nDetermine if a slice is all valid ASCII characters for …\nDetermine if a character is a valid ASCII letter.\nDetermine if a slice is all valid ASCII letters.\nDetermine if a character is a digit.\nDetermine if a character is a digit with a radix known at …\nConvert a character to a digit.\nConvert a character to a digit with a radix known at …\nUnchecked, highly optimized algorithm to convert a char to …\nConvert a digit to a character. This uses a pre-computed …\nConvert a digit to a character with a radix known at …\nFast division/remainder algorithm for u128, without a fast …\nFast division/remainder algorithm for u128, without a fast …\nCalculate a div/remainder algorithm optimized for …\nOptimized fallback division/remainder algorithm for u128.\nCalculate the div/remainder of a value based on the radix.\nExtended precision floating-point type.\nBinary exponent for the extended-precision float.\nGet the exponent component.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMantissa for the extended-precision float.\nGet the mantissa component.\nMask to extract the base prefix character.\nThe base prefix character in the packed struct.\nShift to convert to and from a base prefix as a <code>u8</code>.\nMask to extract the base suffix character.\nThe base suffix character in the packed struct.\nShift to convert to and from a base suffix as a <code>u8</code>.\nNumber format for a <code>C11</code> literal hexadecimal floating-point …\nNumber format for a <code>C11</code> string hexadecimal floating-point …\nNumber format for a <code>C11</code> literal floating-point number.\nNumber format for a <code>C11</code> string floating-point number.\nNumber format for a <code>C18</code> literal hexadecimal floating-point …\nNumber format for a <code>C18</code> string hexadecimal floating-point …\nNumber format for a <code>C18</code> literal floating-point number.\nNumber format for a <code>C18</code> string floating-point number.\nNumber format for a <code>C89</code> string hexadecimal floating-point …\nNumber format for a <code>C89</code> literal floating-point number.\nNumber format for a <code>C89</code> string floating-point number.\nNumber format for a <code>C90</code> string hexadecimal floating-point …\nNumber format for a <code>C90</code> literal floating-point number.\nNumber format for a <code>C90</code> string floating-point number.\nNumber format for a <code>C99</code> literal hexadecimal floating-point …\nNumber format for a <code>C99</code> string hexadecimal floating-point …\nNumber format for a <code>C99</code> literal floating-point number.\nNumber format for a <code>C99</code> string floating-point number.\nBase prefixes are case-sensitive.\nIf base prefixes are case-sensitive.\nBase suffixes are case-sensitive.\nIf base suffixes are case-sensitive.\nExponent characters are case-sensitive.\nIf exponent characters are case-sensitive.\nSpecial (non-finite) values are case-sensitive.\nIf special (non-finite) values are case-sensitive.\nNumber format for a <code>Clojure</code> literal floating-point number.\nNumber format to parse a <code>Clojure</code> float from string.\nNumber format for a <code>Cobol</code> literal floating-point number.\nNumber format to parse a <code>Cobol</code> float from string.\nNumber format for a <code>Coffeescript</code> literal floating-point …\nNumber format to parse a <code>Coffeescript</code> float from string.\nMultiple consecutive digit separators are allowed.\nIf multiple consecutive digit separators are allowed.\nNumber format for a <code>C#1</code> literal floating-point number.\nNumber format to parse a <code>C#1</code> float from string.\nNumber format for a <code>C#2</code> literal floating-point number.\nNumber format to parse a <code>C#2</code> float from string.\nNumber format for a <code>C#3</code> literal floating-point number.\nNumber format to parse a <code>C#3</code> float from string.\nNumber format for a <code>C#4</code> literal floating-point number.\nNumber format to parse a <code>C#4</code> float from string.\nNumber format for a <code>C#5</code> literal floating-point number.\nNumber format to parse a <code>C#5</code> float from string.\nNumber format for a <code>C#6</code> literal floating-point number.\nNumber format to parse a <code>C#6</code> float from string.\nNumber format for a <code>C#7</code> literal floating-point number.\nNumber format to parse a <code>C#7</code> float from string.\nNumber format for a <code>C#</code> literal floating-point number.\nNumber format to parse a <code>C#</code> float from string.\nNumber format for a <code>C++03</code> literal floating-point number.\nNumber format for a <code>C++03</code> string floating-point number.\nNumber format for a <code>C++11</code> string hexadecimal …\nNumber format for a <code>C++11</code> literal floating-point number.\nNumber format for a <code>C++11</code> string floating-point number.\nNumber format for a <code>C++14</code> string hexadecimal …\nNumber format for a <code>C++14</code> literal floating-point number.\nNumber format for a <code>C++14</code> string floating-point number.\nNumber format for a <code>C++17</code> literal hexadecimal …\nNumber format for a <code>C++17</code> string hexadecimal …\nNumber format for a <code>C++17</code> literal floating-point number.\nNumber format for a <code>C++17</code> string floating-point number.\nNumber format for a <code>C++20</code> literal hexadecimal …\nNumber format for a <code>C++20</code> string hexadecimal …\nNumber format for a <code>C++20</code> literal floating-point number.\nNumber format for a <code>C++20</code> string floating-point number.\nNumber format for a <code>C++98</code> literal floating-point number.\nNumber format for a <code>C++98</code> string floating-point number.\nNumber format for a <code>C++</code> literal hexadecimal floating-point …\nNumber format to parse a <code>C++</code> hexadecimal float from string.\nNumber format for a <code>C++</code> literal floating-point number.\nNumber format to parse a <code>C++</code> float from string.\nNumber format for a <code>C</code> literal hexadecimal floating-point …\nNumber format to parse a <code>C</code> hexadecimal float from string.\nNumber format for a <code>C</code> literal floating-point number.\nNumber format to parse a <code>C</code> float from string.\nMask to extract the digit separator character.\nThe digit separator character in the packed struct.\nShift to convert to and from a digit separator as a <code>u8</code>.\nNumber format for a <code>D</code> literal floating-point number.\nNumber format to parse a <code>D</code> float from string.\nNumber format for an <code>Elixir</code> literal floating-point number.\nNumber format to parse an <code>Elixir</code> float from string.\nNumber format for an <code>Elm</code> literal floating-point number.\nNumber format to parse an <code>Elm</code> float from string.\nNumber format for an <code>Erlang</code> literal floating-point number.\nNumber format to parse an <code>Erlang</code> float from string.\nMask to extract the exponent base: the base the exponent …\nThe base for the exponent.\nShift to convert to and from an exponent base as a <code>u32</code>.\nMultiple consecutive exponent digit separators are allowed.\nIf multiple consecutive exponent digit separators are …\nDigit separators are allowed between exponent digits.\nIf digit separators are allowed between exponent digits.\nA digit separator is allowed before any exponent digits.\nIf a digit separator is allowed before any exponent digits.\nMask to extract the exponent radix: the radix for the …\nThe radix for the exponent digits.\nShift to convert to and from an exponent radix as a <code>u32</code>.\nA digit separator is allowed after any exponent digits.\nIf a digit separator is allowed after any exponent digits.\nNumber format for a <code>FORTRAN</code> literal floating-point number.\nNumber format to parse a <code>FORTRAN</code> float from string.\nMultiple consecutive fraction digit separators are allowed.\nIf multiple consecutive fraction digit separators are …\nDigit separators are allowed between fraction digits.\nIf digit separators are allowed between fraction digits.\nA digit separator is allowed before any fraction digits.\nIf a digit separator is allowed before any integer digits.\nA digit separator is allowed after any fraction digits.\nIf a digit separator is allowed after any fraction digits.\nNumber format for a <code>F#</code> literal floating-point number.\nNumber format to parse a <code>F#</code> float from string.\nNumber format for a <code>Gambit-C</code> literal floating-point number.\nNumber format to parse a <code>Gambit-C</code> float from string.\nNumber format for a <code>Golang</code> literal floating-point number.\nNumber format to parse a <code>Golang</code> float from string.\nNumber format for a <code>Guile</code> literal floating-point number.\nNumber format to parse a <code>Guile</code> float from string.\nNumber format for a <code>Haskell</code> literal floating-point number.\nNumber format to parse a <code>Haskell</code> float from string.\nMultiple consecutive integer digit separators are allowed.\nIf multiple consecutive integer digit separators are …\nDigit separators are allowed between integer digits.\nIf digit separators are allowed between integer digits.\nA digit separator is allowed before any integer digits.\nIf a digit separator is allowed before any integer digits.\nA digit separator is allowed after any integer digits.\nIf a digit separator is allowed after any integer digits.\nDigit separators are allowed between digits.\nIf digit separators are allowed between digits.\nNumber format for a <code>Javascript</code> literal floating-point …\nNumber format to parse a <code>Javascript</code> float from string.\nNumber format for a <code>Java</code> literal floating-point number.\nNumber format to parse a <code>Java</code> float from string.\nNumber format for a <code>JSON</code> literal floating-point number.\nNumber format for a <code>Julia</code> literal floating-point number.\nNumber format to parse a <code>Julia</code> float from string.\nNumber format for a <code>Julia</code> literal floating-point number.\nNumber format to parse a <code>Julia</code> float from string.\nNumber format for a <code>Kawa</code> literal floating-point number.\nNumber format to parse a <code>Kawa</code> float from string.\nNumber format for a <code>Kotlin</code> literal floating-point number.\nNumber format to parse a <code>Kotlin</code> float from string.\nA digit separator is allowed before any digits.\nIf a digit separator is allowed before any digits.\nMask to extract the mantissa radix: the radix for the …\nThe radix for the significant digits in the packed struct.\nShift to convert to and from a mantissa radix as a <code>u32</code>.\nNumber format for an <code>Matlab</code> literal floating-point number.\nNumber format to parse an <code>Matlab</code> float from string.\nNumber format for a <code>MongoDB</code> literal floating-point number.\nNumber format for a <code>MySQL</code> literal floating-point number.\nExponent notation is not allowed.\nIf exponent notation is not allowed.\nExponent without a fraction component is not allowed.\nIf an exponent without fraction is not allowed.\nLeading zeros before a float value are not allowed.\nIf leading zeros before a float are not allowed.\nLeading zeros before an integer value are not allowed.\nIf leading zeros before an integer are not allowed.\nPositive sign before the exponent is not allowed.\nIf a positive sign before the exponent is not allowed.\nPositive sign before the mantissa is not allowed.\nIf a positive sign before the mantissa is not allowed.\nSpecial (non-finite) values are not allowed.\nIf special (non-finite) values are not allowed.\nHelper to access features from the packed format struct.\nValidating builder for <code>NumberFormat</code> from the provided …\nNumber format for an <code>Objective-C</code> literal floating-point …\nNumber format to parse an <code>Objective-C</code> float from string.\nNumber format for an <code>OCaml</code> literal floating-point number.\nNumber format to parse an <code>OCaml</code> float from string.\nNumber format for an <code>Octave</code> literal floating-point number.\nNumber format to parse an <code>Octave</code> float from string.\nNumber format for a <code>Perl</code> literal floating-point number.\nNumber format to parse a <code>Perl</code> float from string.\nNumber format for a <code>PHP</code> literal floating-point number.\nNumber format to parse a <code>PHP</code> float from string.\nNumber format for a <code>PostgreSQL</code> literal floating-point …\nNumber format for a <code>Python2</code> literal floating-point number.\nNumber format to parse a <code>Python2</code> float from string.\nNumber format for a <code>Python3.5</code> or lower literal …\nNumber format for a <code>Python3.6</code> or higher literal …\nNumber format for a <code>Python3</code> literal floating-point number.\nNumber format to parse a <code>Python3</code> float from string.\nNumber format for a <code>Python</code> literal floating-point number.\nNumber format to parse a <code>Python</code> float from string.\nAlias for <code>MANTISSA_RADIX</code>.\nThe radix for the significant digits in the packed struct.\nMask to extract the exponent radix: the radix for the …\nAlias for <code>MANTISSA_RADIX_SHIFT</code>.\nNumber format for a <code>ReasonML</code> literal floating-point number.\nNumber format to parse a <code>ReasonML</code> float from string.\nAt least 1 digit in the number is required.\nIf at least 1 digit in the number is required.\nDigits are required after the exponent character. This …\nIf digits are required after the exponent character.\nExponent notation is required.\nIf exponent notation is required.\nPositive sign before the exponent is required.\nIf a sign symbol before the exponent is required.\nDigits are required after the decimal point. This check …\nIf digits are required after the decimal point.\nDigits are required before the decimal point.\nIf digits are required before the decimal point.\nMantissa digits are required (either before or after the …\nIf significant digits are required.\nPositive sign before the mantissa is required.\nIf a sign symbol before the mantissa is required.\nNumber format for a <code>Ruby</code> literal floating-point number.\nNumber format for an octal <code>Ruby</code> literal floating-point …\nNumber format to parse a <code>Ruby</code> float from string.\nNumber format for a <code>Rust</code> literal floating-point number.\nNumber format to parse a <code>Rust</code> float from string.\nNumber format for an <code>R</code> literal floating-point number.\nNumber format to parse an <code>R</code> float from string.\nNumber format for a <code>Sage</code> literal floating-point number.\nNumber format to parse a <code>Sage</code> float from string.\nNumber format for a <code>Scala</code> literal floating-point number.\nNumber format to parse a <code>Scala</code> float from string.\nAny digit separators are allowed in special (non-finite) …\nIf any digit separators are allowed in special …\nNumber format for a <code>SQLite</code> literal floating-point number.\nStandard number format. This is identical to the Rust …\nNumber format for a <code>Swift</code> literal floating-point number.\nNumber format to parse a <code>Swift</code> float from string.\nNumber format for a <code>TOML</code> literal floating-point number.\nA digit separator is allowed after any digits.\nIf a digit separator is allowed after any digits.\nNumber format for a <code>Visual Basic</code> literal floating-point …\nNumber format to parse a <code>Visual Basic</code> float from string.\nNumber format for an <code>XML</code> literal floating-point number.\nNumber format for a <code>YAML</code> literal floating-point number.\nNumber format for a <code>Zig</code> literal floating-point number.\nNumber format to parse a <code>Zig</code> float from string.\nGet the optional character for the base prefix.\nSet the optional character for the base prefix.\nGet the optional character for the base suffix.\nSet the optional character for the base suffix.\nCreate number format for standard, binary number.\nCreate 128-bit, packed number format struct from builder …\nBuild the packed number format, panicking if the builder …\nCreate 128-bit, packed number format struct from builder …\nGet <code>NumberFormatBuilder</code> as a static function.\nGet if base prefixes are case-sensitive.\nSet if base prefixes are case-sensitive.\nGet if base suffixes are case-sensitive.\nSet if base suffixes are case-sensitive.\nGet if exponent characters are case-sensitive.\nSet if exponent characters are case-sensitive.\nGet if special (non-finite) values are case-sensitive.\nSet if special (non-finite) values are case-sensitive.\nGet if multiple consecutive digit separators are allowed.\nSet all consecutive digit separator flags.\nCreate number format for standard, decimal number.\nGet the digit separator for the number format.\nSet the digit separator for the number format.\nGet the digit separator flags from the number format.\nAllow digit separators in all locations for all components.\nGet the error type from the format.\nGet the error type from the radix-only for the format.\nGet the radix for the exponent.\nSet the radix for the exponent.\nGet if multiple consecutive exponent digit separators are …\nSet if multiple consecutive exponent digit separators are …\nGet the exponent digit separator flags from the number …\nSet all exponent digit separator flag masks.\nGet the exponent flags from the number format.\nGet if digit separators are allowed between exponent …\nSet if digit separators are allowed between exponent …\nGet if a digit separator is allowed before any exponent …\nSet if a digit separator is allowed before any exponent …\nGet the radix for exponent digits.\nSet the radix for exponent digits.\nGet if a digit separator is allowed after any exponent …\nSet if a digit separator is allowed after any exponent …\nGet the flags from the number format.\nGet the error type from the format packed struct.\nDetermine if the format packed struct is valid.\nGet if multiple consecutive fraction digit separators are …\nSet if multiple consecutive fraction digit separators are …\nGet the fraction digit separator flags from the number …\nSet all fraction digit separator flag masks.\nGet if digit separators are allowed between fraction …\nSet if digit separators are allowed between fraction …\nGet if a digit separator is allowed before any fraction …\nSet if a digit separator is allowed before any fraction …\nGet if a digit separator is allowed after any fraction …\nSet if a digit separator is allowed after any fraction …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate number format from radix.\nGet the optional character for the base prefix.\nGet the optional character for the base suffix.\nGet if base prefixes are case-sensitive.\nGet if base suffixes are case-sensitive.\nGet if exponent characters are case-sensitive.\nGet if special (non-finite) values are case-sensitive.\nGet the digit separator for the number format.\nGet the radix for the exponent.\nGet if multiple consecutive exponent digit separators are …\nGet if digit separators are allowed between exponent …\nGet if a digit separator is allowed before any exponent …\nGet the radix for exponent digits.\nGet if a digit separator is allowed after any exponent …\nGet if multiple consecutive fraction digit separators are …\nGet if digit separators are allowed between fraction …\nGet if a digit separator is allowed before any fraction …\nGet if a digit separator is allowed after any fraction …\nGet if multiple consecutive integer digit separators are …\nGet if digit separators are allowed between integer digits.\nGet if a digit separator is allowed before any integer …\nGet if a digit separator is allowed after any integer …\nGet the radix for mantissa digits.\nGet if exponent notation is not allowed.\nGet if an exponent without fraction is not allowed.\nGet if leading zeros before a float are not allowed.\nGet if leading zeros before an integer are not allowed.\nGet if a positive sign before the exponent is not allowed.\nGet if a positive sign before the mantissa is not allowed.\nGet if special (non-finite) values are not allowed.\nGet if digits are required after the exponent character, …\nGet if exponent notation is required.\nGet if a sign symbol before the exponent is required.\nGet if digits are required after the decimal point, if the …\nGet if digits are required before the decimal point.\nGet if at least 1 significant digit is required.\nGet if a sign symbol before the mantissa is required.\nGet if any digit separators are allowed in special …\nGet if the format has a base suffix.\nGet if the format has a base suffix.\nGet if the format has a digit separator.\nCreate number format for standard, hexadecimal number.\nGet if multiple consecutive integer digit separators are …\nSet if multiple consecutive integer digit separators are …\nGet the integer digit separator flags from the number …\nSet all integer digit separator flag masks.\nGet if digit separators are allowed between integer digits.\nSet if digit separators are allowed between integer digits.\nGet if a digit separator is allowed before any integer …\nSet if a digit separator is allowed before any integer …\nGet if a digit separator is allowed after any integer …\nSet if a digit separator is allowed after any integer …\nGet the interface flags from the number format.\nGet if digit separators are allowed between digits.\nSet all internal digit separator flags.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDetermine if the number format is valid.\nDetermine if the base prefix character is valid.\nDetermine if the base suffix character is valid.\nDetermine if the digit separator is valid.\nDetermine if the provided exponent flags are valid.\nDetermine if all of the “punctuation” characters are …\nDetermine if the radix is valid.\nDetermine if the radixes in the number format are valid.\nGet if a digit separator is allowed before any digits.\nSet all leading digit separator flags.\nGet the radix for mantissa digits.\nSet the radix for mantissa digits.\nCreate new instance (for methods and validation).\nCreate new <code>NumberFormatBuilder</code> with default arguments.\nGet if exponent notation is not allowed.\nSet if exponent notation is not allowed.\nGet if an exponent without fraction is not allowed.\nSet if an exponent without fraction is not allowed.\nGet if leading zeros before a float are not allowed.\nSet if leading zeros before a float are not allowed.\nGet if leading zeros before an integer are not allowed.\nSet if leading zeros before an integer are not allowed.\nGet if a positive sign before the exponent is not allowed.\nSet if a positive sign before the exponent is not allowed.\nGet if a positive sign before the mantissa is not allowed.\nSet if a positive sign before the mantissa is not allowed.\nGet if special (non-finite) values are not allowed.\nSet if special (non-finite) values are not allowed.\nCreate number format for standard, octal number.\nGet the radix for the significant digits.\nAlias for <code>mantissa radix</code>.\nGet the <code>radix^2</code> for the significant digits.\nGet the <code>radix^4</code> for the significant digits.\nGet the <code>radix^8</code> for the significant digits.\nCreate <code>NumberFormatBuilder</code> using existing values.\nRe-create builder from format.\nGet if at least 1 digit in the number is required.\nSet if digits are required for all float components.\nGet if digits are required after the exponent character.\nSet if digits are required after the exponent character, …\nGet if exponent notation is required.\nSet if exponent notation is required.\nGet if a sign symbol before the exponent is required.\nSet if a sign symbol before the exponent is required.\nGet if digits are required after the decimal point.\nSet if digits are required after the decimal point, if the …\nGet if digits are required before the decimal point.\nSet if digits are required before the decimal point.\nGet if at least 1 significant digit is required.\nSet if at least 1 significant digit is required.\nGet if a sign symbol before the mantissa is required.\nSet if a sign symbol before the mantissa is required.\nGet if any digit separators are allowed in special …\nSet if any digit separators are allowed in special …\nGet if a digit separator is allowed after any digits.\nSet all trailing digit separator flags.\nTrait to simplify creation of a <code>Bytes</code> object.\nSlice iterator that skips characters matching a given …\nIterator over a contiguous block of bytes.\nDetermine if the buffer is contiguous in memory.\nA trait for working with iterables of bytes.\nGet a ptr to the current start of the buffer.\nGet a slice to the current start of the buffer.\nGet the total number of elements in the underlying buffer.\nCreate <code>Bytes</code> from object.\nGet the current number of digits returned by the iterator.\nGet the current number of digits returned by the iterator.\nGet the current index of the iterator in the slice.\nGet the current index of the iterator in the slice.\nGet iterator over exponent digits.\nGet the next value available without consuming it.\nCheck if the next item in buffer is a given value with …\nCheck if the next element is a given value.\nCheck if the next element is a given value without case …\nGet iterator over fraction digits.\nReturns the argument unchanged.\nGet a slice to the full underlying contiguous buffer,\nIncrement the number of digits that have been returned by …\nGet iterator over integer digits.\nCalls <code>U::from(self)</code>.\nGet if no bytes are available in the buffer.\nGet if the iterator cannot return any more elements.\nDetermine if the buffer is contiguous.\nDetermine if the character is a digit.\nCreate new byte object.\nPeek the next value of the iterator, without consuming it.\nCheck if the next element is a given value with optional …\nCheck if the next element is a given value.\nCheck if the next element is a given value without case …\nRead a value of a difference type from the iterator.\nTry to read a the next four bytes as a u32.\nTry to read the next eight bytes as a u64.\nPeek the next value and consume it if the read value …\nRead a value if the value matches the provided one.\nRead a value if the value matches the provided one.\nRead a value if the value matches the provided one without …\nSet the current index of the iterator in the slice.\nSet the current index of the iterator in the slice.\nSkip zeros from the start of the iterator\nGet iterator over special floating point values.\nAdvance the internal slice by <code>N</code> elements.\nAdvance the internal slice by 1 element.\nPeek the next value of the iterator, and step only if it …\nMultiply two unsigned, integral values, and return the …\nMultiply two unsigned, integral values, and return the …\nAn interface for casting between machine scalars, as if <code>as</code> …\nType that can be converted to <code>primitive</code> values with <code>as</code>.\nThe size of this integer type in bits.\nThe size of this float type in bits.\nMask to determine if a full-carry occurred (1 in bit above …\nExponent portion of a <code>denormal</code> float.\nBias of the exponent. See <code>exponent bias</code>.\nBitmask to extract the biased exponent, including the …\nThe number of bits in the exponent.\nThe trait for floating-point <code>numbers</code>.\nBitmask to extract the hidden bit in the exponent, which …\nInfinity (<code>∞</code>).\nPositive infinity as bits.\nIf the number can hold negative values.\nThe base trait for all signed and unsigned <code>integers</code>.\nBitmask to extract the mantissa (significant digits), …\nSize of the significand (mantissa) without the hidden bit.\nThe largest value that can be represented by this integer …\nLargest finite value.\nMaximum (unbiased) exponent value in the float.\nThe smallest value that can be represented by this integer …\nSmallest finite value.\nNot a Number (NaN).\nPositive infinity as bits.\nNegative infinity (<code>−∞</code>).\nThe base trait for all numbers (integers and …\nA value equal to <code>1</code>.\nA value equal to <code>1</code>.\nThe base trait for all <code>primitive</code> types.\nBitmask to extract the sign from the float.\nThe trait for types that support <code>signed</code> integral …\nA value equal to <code>2</code>.\nA value equal to <code>2</code>.\nUnsigned type of the same size.\nThe trait for types that support <code>unsigned</code> integral …\nA value equal to <code>0</code>.\nA value equal to <code>0</code>.\nAllows the high-level conversion of generic types as if <code>as</code> …\nCreates a number from another value that can be converted …\nConvert the value to an <code>f32</code>, as if by <code>value as f32</code>.\nConvert the value to an <code>f64</code>, as if by <code>value as f64</code>.\nConvert the value to an <code>i128</code>, as if by <code>value as i128</code>.\nConvert the value to an <code>i16</code>, as if by <code>value as i16</code>.\nConvert the value to an <code>i32</code>, as if by <code>value as i32</code>.\nConvert the value to an <code>i64</code>, as if by <code>value as i64</code>.\nConvert the value to an <code>i8</code>, as if by <code>value as i8</code>.\nConvert the value to an <code>isize</code>, as if by <code>value as isize</code>.\nConvert the value to a <code>u128</code>, as if by <code>value as u128</code>.\nConvert the value to a <code>u16</code>, as if by <code>value as u16</code>.\nConvert the value to a <code>u32</code>, as if by <code>value as u32</code>.\nConvert the value to a <code>u64</code>, as if by <code>value as u64</code>.\nConvert the value to a <code>u8</code>, as if by <code>value as u8</code>.\nConvert the value to a <code>usize</code>, as if by <code>value as usize</code>.\nGet the number of bits in a value.\nGet the fast ceiling of the quotient from integer division.\nGet the fast ceiling of the quotient from integer division.\nGet the fast ceiling modulus from integer division.\nChecked integer addition. Computes <code>self + i</code>, returning <code>None</code>…\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked integer subtraction. Computes <code>self - i</code>, returning …\nGet the unbiased exponent component from the float.\nReturns the largest integer less than or equal to <code>self</code>.\nRaw transmutation from the unsigned integral type.\nConvert the value from a <code>u32</code>, as if by <code>value as _</code>.\nConvert the value from a <code>u64</code>, as if by <code>value as _</code>.\nReturns true if the float is <code>denormal</code>.\nReturns true if the least-significant bit is even.\nReturns true if the float’s least-significant mantissa …\nReturns true if the float is positive or negative infinity.\nReturns true if the float is NaN.\nReturns true if the least-significant bit is odd.\nReturns true if the float’s least-significant mantissa …\nReturns true if <code>self</code> has a negative sign, including <code>-0.0</code>, …\nReturns true if <code>self</code> has a positive sign, including <code>+0.0</code>, …\nReturns true if the float is NaN, positive infinity, or …\nReturns the number of leading zeros in the binary …\nReturns the natural logarithm of the number.\nGet the mantissa (significand) component from float.\nGet the max of two finite numbers.\nGet the min of two finite numbers.\nReturns true if the float needs a negative sign when …\nGet next greater float.\nGet next greater float for a positive float.\nGet the maximum number of digits before the slice will …\nCalculates <code>self + i</code>.\nCalculates <code>self * i</code>.\nRaises self to the power of <code>exp</code>, using exponentiation by …\nCalculates <code>self - i</code>.\nRaises self to the power of <code>exp</code>, using exponentiation by …\nGet previous greater float, such that …\nGet previous greater float for a positive float. Value …\nRound a positive number to even.\nSaturating integer addition. Computes <code>self + i</code>, saturating …\nSaturating integer multiplication. Computes <code>self * i</code>, …\nSaturating integer subtraction. Computes <code>self - i</code>, …\nRaw transmutation to the unsigned integral type.\nReturns the number of trailing zeros in the binary …\nWrapping (modular) addition. Computes <code>self + i</code>, wrapping …\nWrapping (modular) multiplication. Computes <code>self * i</code>, …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) subtraction. Computes <code>self - i</code>, …\nA <code>Clojure</code> (Lisp) literal number (uses default options).\nA <code>Clojure</code> string short infinity (<code>Infinity</code>).\nA <code>Clojure</code> string long infinity (<code>Infinity</code>).\nA <code>COBOL</code> literal number (uses default options).\nA <code>CoffeeScript</code> string short infinity (<code>Infinity</code>).\nA <code>CoffeeScript</code> string long infinity (<code>Infinity</code>).\nA <code>C#</code> literal number (uses default options).\nA <code>C#</code> string short infinity (<code>Infinity</code>).\nA <code>C#</code> string long infinity (<code>Infinity</code>).\nA <code>C++</code> literal short infinity (<code>INFINITY</code>).\nA <code>C++</code> literal long infinity (<code>INFINITY</code>).\nA <code>C++</code> literal NaN (<code>NAN</code>).\nA <code>C</code> literal short infinity (<code>INFINITY</code>).\nA <code>C</code> literal long infinity (<code>INFINITY</code>).\nA <code>C</code> literal NaN (<code>NAN</code>).\nA <code>D-Lang</code> literal number (uses default options).\nAn <code>Elixir</code> number (uses default options).\nAn <code>Elm</code> literal number (uses default options).\nAn <code>Elm</code> string short infinity (<code>Infinity</code>).\nAn <code>Elm</code> string long infinity (<code>Infinity</code>).\nAn <code>Elm</code> strong NaN (uses default options).\nAn <code>Erlang</code> literal NaN (<code>nan</code>).\nAn <code>Erlang</code> string number (uses default options).\nA <code>FORTRAN</code> literal number (uses default options).\nAn <code>F#</code> literal short infinity (<code>infinity</code>).\nAn <code>F#</code> literal long infinity (<code>infinity</code>).\nAn <code>F#</code> literal NaN (<code>nan</code>).\nA <code>Gambit-C</code> (Lisp) literal number (uses default options).\nA <code>Golang</code> literal number (uses default options).\nA <code>Guile</code> (Lisp) literal number (uses default options).\nA <code>Haskell</code> literal number (uses default options).\nA <code>Haskell</code> string short infinity (<code>Infinity</code>).\nA <code>Haskell</code> string long infinity (<code>Infinity</code>).\nA <code>JavaScript</code> string short infinity (<code>Infinity</code>).\nA <code>JavaScript</code> string long infinity (<code>Infinity</code>).\nA <code>Java</code> literal number (uses default options).\nA <code>Java</code> string short infinity (<code>Infinity</code>).\nA <code>Java</code> string long infinity (<code>Infinity</code>).\nA <code>JSON</code> number (uses default options).\nA <code>Julia</code> string short infinity (<code>Inf</code>).\nA <code>Julia</code> string long infinity (<code>Inf</code>).\nA <code>Kawa</code> (Lisp) literal number (uses default options).\nA <code>Kotlin</code> literal number (uses default options).\nA <code>Kotlin</code> string short infinity (<code>Infinity</code>).\nA <code>Kotlin</code> string long infinity (<code>Infinity</code>).\nA <code>MATLAB</code> literal short infinity (<code>inf</code>).\nA <code>MATLAB</code> literal long infinity (<code>Inf</code>).\nA <code>MongoDB</code> short infinity (<code>Infinity</code>).\nA <code>MongoDB</code> long infinity (<code>Infinity</code>).\nA <code>MySQL</code> number (uses default options).\nAn <code>Objective-C</code> number (uses default options).\nAn <code>OCAML</code> literal short infinity (<code>infinity</code>).\nAn <code>OCAML</code> literal long infinity (<code>infinity</code>).\nAn <code>OCAML</code> literal NaN (<code>nan</code>).\nA <code>Perl</code> literal literal (uses default options).\nA <code>PHP</code> literal short infinity (<code>INF</code>).\nA <code>PHP</code> literal long infinity (<code>INF</code>).\nA <code>PHP</code> literal NaN (<code>NAN</code>).\nA <code>PostgreSQL</code> number (uses default options).\nA <code>Python</code> literal number (uses default options).\nShared trait for all parser options.\nA <code>ReasonML</code> literal short infinity (<code>infinity</code>).\nA <code>ReasonML</code> literal long infinity (<code>infinity</code>).\nA <code>ReasonML</code> literal NaN (<code>nan</code>).\nA <code>Ruby</code> literal short infinity (<code>Infinity</code>).\nA <code>Ruby</code> literal NaN (<code>NaN</code>).\nA <code>Ruby</code> string (uses default options).\nA <code>Rust</code> literal number (uses default options).\nAn <code>R</code> literal short infinity (<code>Inf</code>).\nAn <code>R</code> literal long infinity (<code>Inf</code>).\nA <code>SageMath</code> literal short infinity (<code>infinity</code>).\nA <code>SageMath</code> literal long infinity (<code>Infinity</code>).\nA <code>Scala</code> literal number (uses default options).\nA <code>Scala</code> string short infinity (<code>Infinity</code>).\nA <code>Scala</code> string long infinity (<code>Infinity</code>).\nA <code>SQLite</code> number (uses default options).\nA <code>Swift</code> literal number (uses default options).\nA <code>TOML</code> number (uses default options).\nA <code>Visual Basic</code> literal number (uses default options)\nA <code>Visual Basic</code> short string infinity (uses default options)\nA <code>Visual Basic</code> long string number (uses default options)\nShared trait for all writer options.\nAn <code>XML</code> short infinity (uses default options).\nAn <code>XML</code> short infinity (uses default options).\nA <code>YAML</code> number (uses default options).\nA <code>Zig</code> literal number (uses default options).\nGet an upper bound on the required buffer size.\nDetermine if the options are valid.\nDetermine if the options are valid.\nContains the error value\nContains the success value\nA specialized <code>Result</code> type for lexical operations.\nGet the maximum number of digits that can be processed …\nGet the number of digits that can be always processed …\nCalculate the number of digits that can be processed …")